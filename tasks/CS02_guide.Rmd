---
title: "CS02 Guide"
author: "GEOG-490R"
date: "Spring 2024"
output: 
  html_document:
    theme: spacelab
    code_folding: hide
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr);library(ggplot2);library(terra)
```

### Help Guide

Use the following document to assist in completing Case Study 2. Specifically, this document provides a link to relevant chapters in the book on raster analysis, discusses important terrain analysis function, and describes conditions leading to various levels of avalanche hazard. Be sure to read the avalanche section and visit the UAC website to fully interpret avalanche forecasts. Feel free to reach out with other questions.

\

#### 1. Raster Data Basics

Be sure to review chapters in [the book](https://rspatial.org/spatial/8-rastermanip.html#) that discuss raster data formats and manipulation. In particular, review the Raster Algebra and High-level functions sections.

\

#### 2. Terrain Analysis

Terrain analysis is an important type of raster analysis. Elevation proves to be incredibly useful in the many different environmental and geospatial analyses.

Terrain starts with understanding elevation. Digital elevation models (DEMs) are a form of digital raster data that represents elevation. This can be freely downloaded from multiple sites, including [USGS Earth Explorer](https://earthexplorer.usgs.gov/) site. Global datasets have been made available through remote sensing missions like the Shuttle Radar Topography Mission (SRTM). Elevation is typically displayed in a terrain color scale, though each pixel in the raster represents the ground elevation (typically in meters above sea level).

The `terra` packages comes with a DEM of Luxembourg, and we can use this in conjunction with vector data: 

```{r, fig.height=3.6, align="center"}
filename <- system.file("ex/elev.tif", package="terra")
r <- rast(filename) # read in raster file
# plot(r, main="SpatRaster DEM of Luxembourg")
f <- system.file("ex/lux.shp", package="terra")
p <- vect(f) # read in vector file
plot(r, col = terrain.colors(25), main= "DEM of Luxembourg with Diekirch outlined",plg=list(title="Elevation", cex=0.7, bty="o")) # plot
p_sub <- p[p$NAME_2=="Diekirch",] # only keep Diekirck
plot(p_sub, border='firebrick', lty=2, lwd=2, add=T)
text(p, "NAME_2", cex=0.7)
```

We can also extract or subset spatial datasets based on one another. Your book goes into more detail about some of the high-level functions. Two you will likely use frequently are `crop` and `mask`, which will subset your raster based on a region (polygon):

```{r, fig.height=3.5, align="center"}
r_crop <- crop(x = r, y = p_sub) # crop r to the extent of p_sub
r_mask <- mask(x = r_crop, mask = p_sub, touches = FALSE) # mask values outside of polygon
par(mfrow=c(1,2))
h = hist(r_mask, breaks=9, col=terrain.colors(8), main="Elevational distribution", xlab="Elevation (m)") # create histogram of elevation
plot(r_mask, col=terrain.colors(8), axes=FALSE, mar=c(0,0,0,0)) # plot subset of r
plot(p_sub, border='firebrick', lty=2, lwd=2, add=T)
text(p_sub, "NAME_2", cex=1.2, halo=TRUE)
```

Furthermore, you can calculate statistics based on the entire image (global) and individual areas (zonal):

```{r, fig.height=3.9}
# global stats
e_mean <- global(r, na.rm=T)$mean
cat("The average elevation of Luxembourg is", round(e_mean, 2), "meters above sea level")
# zonal stats
poly_rast <- rasterize(x = p, y = r, field="NAME_2") # rasterize polygon based on unique variables
z <- zonal(r, poly_rast, fun="mean", na.rm=T) # raster to calculate zonal statistics
p$MEAN_E <-  round(z[match(p$NAME_2,z$NAME_2),2], 2)
# plot
plot(r, col=terrain.colors(25), plg=list(title="Elevation", cex=0.7, bty="o", pos=4), mar=c(2,0,2,3.5), axes=F) # plot
legend("topleft", legend="Mean Elevation \nby Canton", bty="n") # add a description
plot(p, border='grey20', lty=3, lwd=1, add=T) # plot cantons
text(p, "MEAN_E", halo=TRUE, adj=0.7) # add mean elevation by canton
```

Elevation can be used to calculate other useful terrain parameters, such as slope, aspect, and a hillshade:

```{r, fig.height=4.4}
# calculate parameters
alt <- disagg(r, 10, method="bilinear")
slope <- terrain(alt, v="slope", unit="degrees")
aspect <- terrain(alt, v="aspect", unit="degrees")
hill <- shade(slope*pi/180, aspect*pi/180, angle = 40, direction = 270)  # hillshade in radians (pi/180)
# plot all with hillshade underneath for visual aid
par(mfrow=c(1,3))
plot_mar = c(2,2,3,4)
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE)
axis(side = 1, cex = 1.5); axis(side = 2, cex = 1.5)
plot(slope, col=rev(colorspace::heat_hcl(10, alpha=0.6)), add=T, axes=FALSE, plg=list(title="Slope", cex=0.8, bty="o"))
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE); axis(side = 1, cex = 1.5)
plot(aspect, col=rev(alpha(c("#3288BD",RColorBrewer::brewer.pal(7, "Spectral")), 0.7)), add=T, axes=FALSE, plg=list(title="Aspect", cex=0.6, bty="o"))
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE); axis(side = 1, cex = 1.5)
plot(alt, col=terrain.colors(25, alpha=0.5), add=TRUE, axes=FALSE, plg=list(title="Elevation", cex=0.8, bty="o"))
```

\

Terrain characteristics derived from the Luxembourge DEM mapped with a hillshade.

|  *Read the ?plot function doc to interpret the map plot arguments. One useful function when plotting over a hillshade is alpha(), which makes a color semi-transparent*

**Slope** describes the steepness of a hillside, typically represented in degrees. For slope, 0º represents a flat surface and 90º would be a vertical cliff face.

**Aspect** is a measurement of the cardinal direction in which the hill is facing and is shown as a cardinal direction (NE) or frequently calculated in degrees *azimuth*. Degrees azimuth includes 0-360º. North is both 0º and 360º, while South is 180º, and East being 90º. The latter is how we will use aspect in our terrain analysis.

**Hillshade** is a visual aid that uses slope, aspect, and a hypothetical location of the sun to create an illumination map. Shadows and rendering gives depth to our vision and helps us more easily interpret terrain. I have plotted a hillshade underneath each layer and added the terrain parameter semi-transparent with `alpha =`. Note the hillshade function expects slope and aspect in radians rather than degrees, so the code above converts with `pi/180`. Finally, I also artificially coarsened the raster with the `disagg()` function.

Note, for different color options in R, I like to Use the [nceas R color cheatsheet](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf).

\

#### 3. Avalanche Hazard

In part of your lab, you will be analyzing avalanche forecast information with terrain data. Let's go over conditions that can lead to an avalanche. Avalanche hazard is basically a function of slope, aspect, and elevation:

- Avalanches only occur on *slopes between 30-45 degrees*. This does not change over time, however, these slopes can be less hazardous once the snowpack stabilizes.
- Snowpack stability changes over time depending on *several meteorological factors*, such as new snow accumulation, temperature, windpeed, etc. These variables cause greater avalanche hazard across *varying aspects and elevations*. 
- Dangerous aspects and elevations vary seasonally and even from day to day, depending on meteorological conditions. This is why the avalanche forecast must be updated daily, because snow stability can change rapidly.

Navigate to [Utah Avalanche Center](https://utahavalanchecenter.org/) (UAC) webpage to read about the current avalanche conditions. Select either Salt Lake or Provo forecast area and pay special attention to the rose diagram on the actual forecast for the day. This is the colorful, multi-layered image showing the danger (e.g. low/considerable) at different elevations, slopes, and aspects. Learn more about reading the avalanche forecast and interpreting the rose diagram under the [forecast tutorial](https://utahavalanchecenter.org/forecast/tutorial) section on the UAC site.

You are going to use forecast information to create an avalanche hazard map by combining terrain features and a basic model. You will then assess the accuracy of the forecast based on avalanche observations for the same day.

**Reclassification and Combining Data:**

In the assignment, you will need to learn how to reclassify the values of raster and combine layers together, similar to a suitability analysis. There is more than one way to do so.

First, let's *artificially adjust* the slope layer we created of Luxembourg to be steeper, then we will find all slope angles greater than 20º. We can use raster algebra, specifically, boolean operations to determine where this condition is met. The result of a boolean operation on a raster is a new TRUE (1) or FALSE (0) raster showing pixels that met the condition:

```{r, fig.height=4.4}
par(mfrow=c(1,2))
plot_mar = c(2,2,3,4)
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE, main = "Steeper slopes")
new_slope = slope * 12
plot(new_slope, col=rev(colorspace::heat_hcl(10, alpha=0.6)), add=T, axes=FALSE, plg=list(title="Slope", cex=0.8, bty="o"))
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE, main = "Slopes > 20º")
slopes_20 = new_slope > 20
plot(slopes_20, col=alpha(c(NA,"red"), 0.5), add=T, legend="topright", bty="n", axes=FALSE)
```

We can also combine conditions. Let's find pixels that have a slope greater than 20º and  elevations between 300-450 meters:

```{r, fig.width=4}
elev_400 = (alt > 300) & (alt < 450)
cond1 = slopes_20 * elev_400
plot(hill, col=grey(0:100/100), legend=FALSE, axes=FALSE, main = "Condition 1")
plot(cond1, col=alpha(c(NA,"red"), 0.5), add=T, legend="topright", plg=list(title="Condition met?", legend = c("No", "Yes"), cex=0.7, bty="o"), axes=FALSE)
```

You can see how you can easily adjust your data to focus on specific ranges. 

The `classify()` function in the terra package helps reclassify ranges in a dataset to multiple new values. This can be incredibly useful as well. Along with the input raster is a matrix table that contains columns that provide a range of values with new values (min, max, new value) and rows for each new classification. For example:

```{r, fig.width=3.5}
m <- c(140, 375, 1, # min, max, new value
       375, 560, 2)
rcl_mat <- matrix(m, ncol=3, byrow=TRUE) # create matrix
r_class = classify(r, rcl_mat) # run function
plot(hill, col=grey(0:100/100), legend=FALSE, mar=plot_mar, axes=FALSE, main = "Classify Function")
plot(r_class, col=alpha(c("blue", "red"), 0.5), add=T, legend="topright", bty='n', axes=FALSE)
```

Be sure to read about other arguments in this function.

\

**Use the CS02 doc to get started on this assignment!**

\

